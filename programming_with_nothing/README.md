# 第6章 無からのプログラミング

## TypeScriptでラムダ計算をまねる
 - 変数の参照
 - アロー関数の生成
 - アロー関数の呼び出し

だけをつかって、ラムダ計算を実装する。(だだし、省略形としての定数を使うことはできる)

### 数の表現方法
アクションを実行した回数を数としすると、アクションはアロー関数の呼び出しに相当するので数nはアロー関数をn回呼び出したものとして実装することができる

### 再帰関数の定義
再帰関数は関数内で自信を呼び出している関数だが、1) IFの実装が**2つの関数(ラムダ)を引数として呼び出す**となっているため、IFの分岐条件が決まる前に両方の処理が評価されてしまい、無限ループとなってしまう。2) 再帰関数内で再帰関数名により関数を呼び出す実装では、**省略形を元の式に戻すことができない**。

 - 1)の解決法
 等価性を利用し、関数の評価を遅延させる。元の関数fがあった場合、fと同じ引数を取りfをすぐに呼び出す関数gは等価であり、gが評価されるまで再帰呼び出しを遅延させることができる。
```
// f と g は等価なので、myfunc1とmyfunc2は等価であるが, myfunc1評価時にはfが定義されていないためエラーとなる。
const g = x => f(x);
// const myfunc1 = f;
const myfunc2 = g;

const f = x => x + 1;
```

 - 2)の解決法
 **Y combinator**と呼ばれる再帰関数を定義するために設計されたヘルパーコードにより解決できる。
Y comibnatorでは1)と同じ問題が発生するので、それに対応した**Z combinator**を使う。
```
const Y = f => (x => f(x(x)))(x => f(x(x)));
const Z = f => (x => f(y => x(x)(y)))(x => f(y => x(x)(y)));
```